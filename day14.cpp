/*We are learning about Function Objects!
These are objects that act like functions because
we can call them like so. 
ObjectName objectInstance;
objectInstance(args...) << is a call to the ObjectName instance
which is possible because ObjectName is defined likeso.

class ObjectName
{
	public:
		void operator()(){std::cout << "I'm Marquise " << std::endl;}	
This operator overload can return any type and take any amount
of parameters.		
};

for_each(vs.begin(), vs.end(), PrintString(cerr, '\n'))

class PrintString
{
	public:
		PrintString(std::ostream &os = std::cout, char c = ' ');
		void operator()(const std::string &s);


};when we write a lambda expression it is translated to an unnamed object
of an unnamed class. The class generated by the lambda contains an overloaded
function-call operator. 

Suppose we have 

#include <algorithm>
for_each(vs.begin(), vs.end(), [](const std::string &a, const std::string &b){return a.size() < b.size();});

This lambda expression is comparable to

class ShorterString
{
	public:
		bool operator () (const std::string &a, const std::string &b)
		{
			return a.size() < b.size();
		}	
};

Lambdas may not change their captured values! They capture values
through []

Lambda captures values through [](){}. If we pass the variable in the 
capture as a value, it will be copied by the Lambda and the unnamed object
of an unnamed class generated by the lambda will have a constructor that setst
a private data member. 

[sz](std::string &s){return s.size() >= sz;}

translates to 

class SizeComp
{
	public:
		SizeComp(size_t n) : sz(n){}

		bool operator ()(std::string &s)
		{
			return s.size() >= sz;
		}	

	private:
		size_t sz;
};

Classes generated from lambda expression have a deleted 
default constructor, deleted assignment operators, and a default
destructor.

Library Function Objects
#include <functional>

plus<Type>
negate<Type>
minus<Type>
multiplies<Type>
divides<Type>
modulus<Type>
negate<Type>
equal_to<Type>
not_equal_to<Type>
greater<Type>
greater_equal<Type>
less<Type>
less_equal<Type>
logical_and<Type>
logical_or<Type>
logical_not<Type>


Library Defined Function Objects are functions that apply the 
implied call operator on inputs of type that you specify for example

plus<string> p;

p("Marquise", " Rosier"); will produce a concatenated string 
by applying addition operator on two string types.

Modulus<Type> will apply modulus on two given inputs.

This library guarantees that we can sort a vector or a container of 
pointers!!!!!!!! 

Most Associative containers use less<Type> to order their elements,
thus we can define a set of pointers or use a pointer as the key
in a map without specifying less directly!!!!

Map, Set can be composed of keys and elements, respectively, that are
pointers.